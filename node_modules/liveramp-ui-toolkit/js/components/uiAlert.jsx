import CSSTransitionGroup from 'react-addons-css-transition-group';
import UiIcon from './uiIcon.jsx';

/* User provides:
* * > type - the type of the alert (string)
* *      + must be one of [success, warning, information, error] - otherwise defaults to information
* * > message - the message to be shown (string)
* * > handleClose - function for handling the click of the 'x' (function)
* * > permanent - alert will stay on the page until the user clicks to close, defaults to false (boolean)
*/

const docs = {
  title: "UiAlert",
  propDetails: [
    { title: "type",
      required: true,
      type: "string",
      description: "The type of the alert - must be one of [success, warning, information, error] - otherwise defaults to information." },
    { title: "message",
      required: true,
      type: "string",
      description: "The message to be shown." },
    { title: "handleClose",
      required: true,
      type: "function",
      description: "Handles the user closing the alert." },
    { title: "permanent",
      required: false,
      type: "boolean",
      description: "If true, alert will stay on the page until the user clicks close. Otherwise alert closes after 8 seconds of non interaction." }
  ]
}

const alertTypes = ['success', 'warning', 'information', 'error'];


const UiAlert = React.createClass({
  getInitialState() {
    return ({
      timeToClose: new Date().getTime() + 8000,
      mouseOver: false,
      removeAlert: false
    });
  },

  componentDidMount() {
    if (!this.props.permanent) {
      const intervalId = setInterval(() => {
        if (new Date().getTime() > this.state.timeToClose && !this.state.mouseOver) {
          this.removeAlert();
        }
      }, 1000);
      this.intervalId = intervalId
    }
  },

  componentWillReceiveProps () {
    this.setState({timeToClose: new Date().getTime() + 8000});
  },

  componentWillUnmount() {
    if (Number.isInteger(this.intervalId)) {
      clearInterval(this.intervalId);
    }
  },

  componentDidUpdate(prevProps, prevState) {
    //Refresh elevio tooltips (here rather than across apps: (Admin / Connect ...))
    //if we move to open source, we may want to reconsider how we handle this case
    if (window._elev && window._elev.reloadTips) {
      window._elev.reloadTips();
    }
  },

  render() {
    let type = this.props.type;
    const message = this.props.message;

    if (!alertTypes.includes(type)) {
      type = 'information';
    }

    const alertMessage = <div key={1} className={'lr-ui-alert-wrapper ' + type}>
      <div className='lr-ui-alert-container'>
        <div className='lr-ui-alert-message'>
          {message}
        </div>
        <div onClick={this.removeAlert} className='lr-ui-alert-close'>
          <UiIcon
            icon={'cancel'}
            dimensions={[14, 14]}
            classes={ type === "warning" ? "sidebar-dark" : "white"}
            />
        </div>
      </div>
    </div>;

    return (
      <div onMouseEnter={this.mouseOver} onMouseLeave={this.mouseLeave} className='lr-ui-alert'>
        <CSSTransitionGroup
          transitionName='lr-ui-alert'
          transitionAppear={true}
          transitionAppearTimeout={0}
          transitionEnter={false}
          transitionLeave={true}
          transitionLeaveTimeout={0} >
          {!this.state.removeAlert ? alertMessage : null }
        </CSSTransitionGroup>
      </div>
    );
  },

  mouseOver() {
    if (!this.state.removeAlert) {
      this.setState({
        mouseOver: true
      });
    }
  },

  mouseLeave() {
    if (!this.state.removeAlert) {
      this.setState({
        mouseOver: false,
        timeToClose: new Date().getTime() + 8000
      });
    }
  },

  removeAlert() {
    setTimeout(() => {this.props.handleClose()}, 350);
    this.setState({
      removeAlert: true
    });
  }
});

export default UiAlert;

export { docs };
